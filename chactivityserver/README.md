# How to run a ChactivityServer

## Dependencies

To run this project, you will need `openssl-devel` and [`rust`](https://www.rust-lang.org/tools/install) on your system.
Then, a working configuration for your http server and for the project will be necessary.

## Nginx

This is an example of configuration for NGINX (with `certbot` for https-certificates)

```nginx
server {
    server_name example.tld; # managed by Certbot
    root /var/www/example/public/;

    location /inbox {
        proxy_pass http://localhost:8080;
    }

    location /users {
        proxy_pass http://localhost:8080;
    }

    location /.well-known/webfinger {
        proxy_pass http://localhost:8080;
    }

    location / {
    }

    error_page 404 /404.html;
        location = /40x.html {
    }

    error_page 500 502 503 504 /50x.html;
        location = /50x.html {
    }


    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/example-tld/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/example-tld/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}
```

## Configuration

`config.json` can be used as a starting point to configure the project.
`.keys/privkey.pem` and `.keys/publickey.pem` are used to sign post requests between instances.
I use the private key generated by `certbot` (and do a static link). To get a public key:

```sh
openssl rsa -in /etc/letsencrypt/live/example/privkey.pem -outform PEM -pubout -out /var/www/example/chactivityserver/.keys/pubkey.pem
```

# How it works?

## Preferred links

This project mostly uses 3 standards:

+ [ActivityPub](https://www.w3.org/TR/activitypub/) with [Mastodon helpers](https://docs.joinmastodon.org/spec/activitypub/)
+ [WebFinger](https://www.rfc-editor.org/rfc/rfc7033)
+ [Http-signatures](https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12)

## Profile discovery

There is mostly 3 different aspects. Profile discovery, announcing articles, retrieving articles. The first step is profile discovery.
Any *chactivity server* uses by default a single account (`chef`) and the discovery is done via the **WebFinger** protocol.

### Webfinger

To discover a profile, servers MUST do a request to `example.tld/.well-known/webfinger?resource=acct:chef@example.tld`. This will return a JSON
response containing the link to the profile (`example.tld/users/chef`)

### Profile

`example.tld/users/chef` is accepting **GET** requests with the header: `Accept: application/activity+json`.
And is returning a JSON response containing the profile, links to the outbox, followers, inbox and linked inbox
(which is the same as the inbox, as there is only one user).

### Outbox

`example.tld/users/chef/outbox` is accepting **GET** requests with the header: `Accept: application/activity+json`.
The outbox contains all articles already written. So that any server can get all past interactions.
The outbox is divided in pages of 12 articles. A page can be accessed by passing `page=1` to the request (or any other number).
Page=1 is the first page. The last page is announced in the outbox description (`page=0` or no **page** parameter).

Finally, the outbox content is cached in the cache directory. This cache is automatically invalidated when a new
recipe in `/content/recettes` is detected (we store the current number of articles and the last modification date in `.cache/date_file.txt`).

However, this is not enough to have incoming articles on remote instances. The server MUST announce new articles
by posting to followers inbox.

## Posting events

### Http-Signatures

Sending events to other instances MUST include a HTTP-Signature. This signature is generated by:

1. Using the keys provided in the configuration (a classic RSA key)
2. It uses the `rsa-sha256` algorithm to sign requests. This is done via a fork of [`http-sig`](https://github.com/AmarOk1412/http-signatures)
3. This adds a new header to the signed requests like:

```
Signature: keyId="rsa-key-1",algorithm="hs2019",
     created=1402170695, expires=1402170995,
     headers="(request-target) (created) (expires)
       host date digest content-length",
     signature="Base64(RSA-SHA256(signing string))"
```

### Posting on the Fediverse

When a new article is detected, the cache is refreshed and articles are transformed into a JSON:

```json
{
    "@context": [
        "https://www.w3.org/ns/activitystreams",
        {
            "ostatus": "http://ostatus.org#",
            "atomUri": "ostatus:atomUri",
            "inReplyToAtomUri": "ostatus:inReplyToAtomUri",
            "conversation": "ostatus:conversation",
            "sensitive": "as:sensitive",
            "toot": "http://joinmastodon.org/ns#",
            "votersCount": "toot:votersCount"
        }
    ],
    "id": format!("https://{}/recettes/{}", self.config.domain, filename_without_extension),
    "type": "Create",
    "actor": format!("https://{}/users/{}", self.config.domain, self.config.user),
    "published": published,
    "to": [
        "https://www.w3.org/ns/activitystreams#Public"
    ],
    "cc": [
        format!("https://{}/users/{}/followers", self.config.domain, self.config.user),
    ],
    "object": {
        "id": format!("https://{}/recettes/{}", self.config.domain, filename_without_extension),
        "type": "Article",
        "summary": null,
        "inReplyTo": null,
        "published": published,
        "url": format!("https://{}/recettes/{}", self.config.domain, filename_without_extension),
        "attributedTo": format!("https://{}/users/{}", self.config.domain, self.config.user),
        "to": [
            "https://www.w3.org/ns/activitystreams#Public"
        ],
        "cc": [
            format!("https://{}/users/{}/followers", self.config.domain, self.config.user),
        ],
        "sensitive": false,
        "atomUri": format!("https://{}/recettes/{}", self.config.domain, filename_without_extension),
        "content": markdown,
        "name": match_title.get(1).map_or("Chalut!", |m| m.as_str()).to_owned(),
        "mediaType": String::from("text/markdown"),
        "attachment": attachments,
        "tag": tags_value,
        "license": self.config.license
    }
}
```

`attachments`: are the list of images in the article (checked in `config.img_dir/recipe-name/`)
`tags` are retrieved from the article if the list in the config is empty.

This JSON is sent to each followers inbox via signed requests.
If two followers got a shared inbox, only one **POST** will be done.

### Followers

Followers are cached in `.cache/followers` and available via `example.tld/users/chef/followers`.

A new follower is added to the list by receiving a **Follow** activity in the inbox. Then, an **Accept** activity
is sent to the follower inbox.

Mechanism is described [there](https://www.w3.org/TR/activitypub/#follow-activity-outbox).

## Other activities

### Liking or boosting recipes

Likes and boosts are cached in `.cache/likes.json` and available via `example.tld/users/chef/likes` with the following parameters:
+ *object*  the current pathname (e.g. /recettes/profiteroles-chocolat)
+ *wanted_type* like or boost

This is shown in the website via a `fetch()` request done in `layouts/_default/single.html`

## Receiving articles

Not implemented yet!
